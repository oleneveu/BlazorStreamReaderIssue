@page "/streamdata"
@using BlazorStreaming.Shared
@using System.Text;
@implements IAsyncDisposable
@inject HttpClient Http

<PageTitle>Streaming</PageTitle>

<h1>Streaming</h1>

<p role="status">Streamed data: @streamedData</p>

@code
{
    private string? streamedData;
    private CancellationTokenSource _cts = new CancellationTokenSource();
    private Task _streamingTask = null!;

    protected override Task OnInitializedAsync()
    {
        streamedData = "Waiting for server data...";

        _streamingTask = BeginReadText();           // Reading the data through a StreamReader brings out the issue
        //_streamingTask = BeginReadByteCount();    // Reading the data directly from the stream works as expected

        return Task.CompletedTask;
    }

    async ValueTask IAsyncDisposable.DisposeAsync()
    {
        _cts.Cancel();
        _cts.Dispose();
        await _streamingTask;
    }

    /// <summary>
    /// This is the method that demonstrate the issue.
    /// A request is made to an endpoint that sends its response slowly.
    /// A StreamReader is used to read that response line-by-line, and each line is displayed on the page on is turn.
    /// </summary>
    private async Task BeginReadText()
    {
        using var request = new HttpRequestMessage(HttpMethod.Get, "DataStreaming");
        request.SetBrowserResponseStreamingEnabled(true);

        using var response = await Http.SendAsync(request, HttpCompletionOption.ResponseHeadersRead, _cts.Token);
        try
        {
            var responseStream = await response.Content.ReadAsStreamAsync();

            using (var sr = new StreamReader(responseStream, bufferSize: 128)) // 128: Minimum value for StreamReader
            {
                // The issue happends here: when using Blazor 7, sr.ReadLineAsync() does not return before 128 bytes of data have been received from the server
                // even if that data contains several line-breaks.
                // With Blazor 6, a line of text is returned by the StreamReader any time a line-break is received.
                while ((streamedData = await sr.ReadLineAsync()) != null) // Not passing the cancellation token to be .Net 6 compatible. Passing the token has no effect on the issue.
                {
                    _cts.Token.ThrowIfCancellationRequested();
                    this.StateHasChanged();// Update the UI
                }
            }
        }
        catch (OperationCanceledException)
        {
        }
    }

    /// <summary>
    /// This method is an alternative to 'BeginReadText()' that reads the data directly from the response stream and displays the number of bytes read.
    /// It shows that the data is really received each time a line of text is sent by the server.
    /// </summary>
    private async Task BeginReadByteCount()
    {
        using var request = new HttpRequestMessage(HttpMethod.Get, "DataStreaming");
        request.SetBrowserResponseStreamingEnabled(true);

        using var response = await Http.SendAsync(request, HttpCompletionOption.ResponseHeadersRead, _cts.Token);
        try
        {
            var responseStream = await response.Content.ReadAsStreamAsync();

            // Read the response chunk by chunk and count the number of bytes
            int byteCount = 0;
            var bytes = new byte[10];
            while (!_cts.Token.IsCancellationRequested)
            {
                var read = await responseStream.ReadAsync(bytes, _cts.Token);
                if (read == 0) // End of stream
                    return;

                byteCount += read;
                streamedData = byteCount.ToString("00000");

                // Update the UI
                StateHasChanged();
            }

            streamedData = "End of stream";
            this.StateHasChanged();
        }
        catch (OperationCanceledException)
        {
        }
    }
}
